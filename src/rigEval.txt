//-------------------------------------------------------
// rigEval.cpp
//-------------------------------------------------------
// the rigMachine expression evaluator

#include <myDebug.h>
#include "rigMachine.h"
#include "rigExpression.h"

#define dbg_eval 	-1

#define MAX_OP_STACK	32
#define MAX_VAL_STACK   32
#define MAX_COND_STACK  32

#define IS_EXP_OP(byte)	(byte >= EXP_NOT && byte < EXP_LOGICAL_AND)
	// actual ops

#define OP_TOKEN(op)	rigTokenToString(op + RIG_TOKEN_LEFT_PAREN - EXP_LEFT_PAREN)
	// display ops include PARENS

const char *VAL_DISPLAY(evalResult_t *rslt)
{
	static char local_buf[128];
	if (!rslt->is_string)
		sprintf(local_buf,"%d",rslt->value);
	else
		sprintf(local_buf,"\"%s\"",rslt->text);
	return local_buf;
}



int op_top;
int val_top;
int cond_top;

uint8_t 	 op_stack[MAX_OP_STACK];
evalResult_t val_stack[MAX_VAL_STACK];
uint16_t 	 cond_stack[MAX_COND_STACK];


//-----------------------------------------------
// utilities
//-----------------------------------------------

bool pushOp(uint8_t op)
{
	display(dbg_eval+1,"    pushOp(%d) %d=%s",op_top,op,OP_TOKEN(op));
	if (op_top >= MAX_OP_STACK)
	{
		rig_error("OPERATOR STACK OVERFLOW");
		return false;
	}
	op_stack[op_top++] = op;
	return true;
}

bool popOp(uint8_t *op)
{
	if (!op_top)
	{
		rig_error("OPERATOR STACK UNDERFLOW");
		return false;
	}
	*op = op_stack[--op_top];
	display(dbg_eval+1,"    popOp(%d) %d=%s",op_top,*op,OP_TOKEN(*op));
	return true;
}

bool pushVal(evalResult_t *val)
{
	display(dbg_eval+1,"    pushVal(%d) %s",val_top,VAL_DISPLAY(val));
	if (val_top >= MAX_VAL_STACK)
	{
		rig_error("OPERAND STACK OVERFLOW");
		return false;
	}
	memcpy(&val_stack[val_top++],val,sizeof(evalResult_t));
	return true;
}

bool pushValInt(uint16_t value)
{
	display(dbg_eval+1,"    pushValInt(%d) %d",val_top,value);
	if (val_top >= MAX_VAL_STACK)
	{
		rig_error("OPERAND STACK(TEXT) OVERFLOW");
		return false;
	}
	val_stack[val_top].is_string = 0;
	val_stack[val_top].value = value;
	val_top++;
	return true;
}

bool pushValText(const char *text)
{
	display(dbg_eval+1,"    pushValText(%d) \"%s\"",val_top,text);
	if (val_top >= MAX_VAL_STACK)
	{
		rig_error("OPERAND STACK(TEXT) OVERFLOW");
		return false;
	}
	val_stack[val_top].is_string = 1;
	val_stack[val_top].text = text;
	val_top++;
	return true;
}


bool popVal(evalResult_t *val)
{
	if (val_top >= MAX_VAL_STACK)
	{
		rig_error("OPERAND STACK OVERFLOW");
		return false;
	}
	memcpy(val,&val_stack[--val_top],sizeof(evalResult_t));
	display(dbg_eval+1,"    popVal(%d) %s",val_top,VAL_DISPLAY(&val_stack[val_top]));
	return true;
}


bool popValToCondition()
{
	if (cond_top >= MAX_COND_STACK)
	{
		rig_error("CONDITIONAL STACK OVERFLOW");
		return false;
	}
	evalResult_t cond;
	if (!popVal(&cond))
		return false;
	display(dbg_eval+1,"    popValToCondition(%d) cond=%d",cond_top,cond.value);
	cond_stack[cond_top++] = cond.value;
	return true;
}

bool popCondition(uint16_t *cond)
{
	if (!cond_top)
	{
		rig_error("CONDITIONAL STACK UNDERFLOW");
		return false;
	}
	*cond = cond_stack[--cond_top];
	display(dbg_eval+1,"  popCondition(%d) cond=%d",cond_top,*cond);
	return true;
}



const int precedence(uint8_t op)
	// I added COLON as the lowest precedence in C++ scheme
	//  3   :
	// Mine are in reverse order from C++, which places them like this:
	//  4   !					logical and binary NOT	right-to-left
	//	5 	a*b   a/b   a%b 	Multiplication, division, and remainder
	//	6 	a+b   a-b 			Addition and subtraction
	//	7 	<<   >> 			Bitwise left shift and right shift
	//	8 	<=> 				Three-way comparison operator (since C++20)
	//	9 	<   <=   >   >= 	For relational operators < and <= and > and >= respectively
	//	10 	==   != 			For equality operators = and != respectively
	//	11 	a&b 				Bitwise AND
	//	12 	^ 					Bitwise XOR (exclusive or)
	//	13 	| 					Bitwise OR (inclusive or)
	//	14 	&& 					Logical AND
	//	15 	|| 					Logical OR
	//  16  a?b:c 			`	Ternary conditional  Right-to-left
	//							The expression in the middle of the conditional operator
	//							is parsed as if parenthesized: its precedence relative to ?
	//							is ignored.
{
	switch(op)
	{
		// case EXP_COLON :
		// 	return 0;
		case EXP_NOT :
			return 10;
		case EXP_TIMES :
		case EXP_DIVIDE :
			return 9;
		case EXP_PLUS :
		case EXP_MINUS :
			return 8;
		case EXP_GT :
		case EXP_GE :
		case EXP_LT :
		case EXP_LE :
			return 7;
		case EXP_EQ :
		case EXP_NE :
			return 6;
		case EXP_BITWISE_AND :
			return 5;
		case EXP_BITWISE_OR :
			return 4;
		case EXP_LOGICAL_AND :
			return 3;
		case EXP_LOGICAL_OR :
			return 2;
		case EXP_QUESTION :
			return 11;
	}
	return 0;
}


//----------------------------------------------------------------------------------
// doOp()
//----------------------------------------------------------------------------------

bool doOp(uint8_t op)
{
	display(dbg_eval+1,"doOp(%d=%s)",op,OP_TOKEN(op));
	proc_entry();

	evalResult_t val1;
	evalResult_t val2;

	if (!popVal(&val2))
		return false;

	// unary, right associative not

	if (op == EXP_NOT)
	{
		val1.is_string = 0;
		val1.value = !val2.value;
	}
	else	// regular left associate bin_ops
	{
		if (!popVal(&val1))
			return false;

		switch (op)
		{
			case EXP_PLUS :
				val1.value += val2.value;
				break;
			case EXP_MINUS :
				val1.value -= val2.value;
				break;
			case EXP_TIMES :
				val1.value *= val2.value;
				break;
			case EXP_DIVIDE :
				if (val2.value == 0)
				{
					rig_error("Divide by zero!!");
					proc_leave();
					return false;
				}
				val1.value /= val2.value;
				break;
			case EXP_EQ :
				val1.value = val1.value == val2.value;
				break;
			case EXP_NE :
				val1.value = val1.value != val2.value;
				break;
			case EXP_GT :
				val1.value = val1.value > val2.value;
				break;
			case EXP_GE :
				val1.value = val1.value >= val2.value;
				break;
			case EXP_LT :
				val1.value = val1.value < val2.value;
				break;
			case EXP_LE :
				val1.value = val1.value <= val2.value;
				break;
			case EXP_BITWISE_OR :
				val1.value |= val2.value;
				break;
			case EXP_BITWISE_AND :
				val1.value &= val2.value;
				break;
			case EXP_LOGICAL_OR :
				val1.value = val1.value || val2.value;
				break;
			case EXP_LOGICAL_AND :
				val1.value = val1.value && val2.value;
				break;
		}
	}	// bin_ops

	if (!pushVal(&val1))
		return false;
	proc_leave();
	return true;
}



//---------------------------------------------
// getAtom()
//---------------------------------------------

bool rigMachine::getAtom(uint8_t byte, const uint8_t *code, uint16_t *offset)
	// it's either an inline number, or a
{
	int val_start = val_top;

	display(dbg_eval,"getAtom at %d == 0x%02x  val_start=%d",*offset-1,byte,val_start);
	proc_entry();

	uint8_t inline_op = byte & 0x3f;

	bool ok = 1;
	if (byte == EXP_TEXT)
	{
		const char *s = (const char *) &code[*offset];
		display(dbg_eval,"TEXT = %s",s);
		ok = pushValText(s);
		(*offset) += strlen(s) + 1;

		// generally, getAtom() advances the offset so that
		// offset is pointing at the next executable charaacter,
		// which is typically a binary op ...
	}
	else if (byte == EXP_STRING)
	{
		byte = code[(*offset)++];
		display(dbg_eval,"STRING[sub_exp]",0);
		ok = evaluate(byte, code, offset);

		// but this recruve call to evaluate() ended on the right bracket
		// and advanced the offset to the byte after it.
		// therefore, we don't check the right bracket OR advance here ...

		// if (ok && code[*offset] != EXP_RIGHT_BRACKET)
		// {
		// 	rig_error("RIGHT_BRACKET expected at %d",*offset);
		// 	ok = false;
		// }
		if (ok)
		{
			// byte = code[(*offset)++];
			uint8_t num = val_stack[--val_top].value;
			uint16_t off = rig_header.strings[num] - 1;
			const char *s = &rig_code.string_pool[off];
			display(dbg_eval,"STRING[%d] off(%d) = %s",num,off,s);
			ok = pushValText(s);
		}
	}
	else if (byte == EXP_VALUE)
	{
		byte = code[(*offset)++];
		display(dbg_eval,"VALUE[sub_exp]",0);
		ok = evaluate(byte, code, offset);
		// if (ok && code[*offset] != EXP_RIGHT_BRACKET)
		// {
		// 	rig_error("RIGHT_BRACKET expected at %d",*offset);
		// 	ok = false;
		// }
		if (ok)
		{
			// byte = code[(*offset)++];
			uint8_t num = val_stack[--val_top].value;
			uint8_t value = m_rig_state.values[num];
			display(dbg_eval,"VALUE[num=%d] value=%d",num,value);
			ok = pushValInt(value);
		}
	}

	// otherwise everything *should* be an inline

	else if (!(byte & EXP_INLINE))
	{
		rig_error("INLINE op expected");
		ok = 0;
	}
	else
	{
		uint8_t value = code[(*offset)++];

		if (byte & EXP_INLINE_ID)
		{
			display(dbg_eval,"INLINE ID(%d:%s)",value,&rig_code.define_pool[rig_header.define_ids[value] - 1]);
			value = rig_header.define_values[value];
		}

		if (inline_op == EXP_LED_COLOR)
		{
			display(dbg_eval,"INLINE LED_COLOR(%d) = %s",rigTokenToText(RIG_TOKEN_LED_BLACK + value));
		}
		else if (inline_op == EXP_DISPLAY_COLOR)
		{
			display(dbg_eval,"INLINE DISPLAY_COLOR(%d) = %s",rigTokenToText(RIG_TOKEN_DISPLAY_BLACK + value));
		}

		if (inline_op == EXP_STRING)
		{
			uint16_t off = rig_header.strings[value];
			const char *s = &rig_code.string_pool[off];
			display(dbg_eval,"INLINE_STRING[%d] at %d = %s",value,off,s);
			ok = pushValText(s);
		}
		else
		{
			if (inline_op == EXP_VALUE)
			{
				display(dbg_eval,"INLINE VALUE[%d]",value);
				value = m_rig_state.values[value];
			}
			else
				display(dbg_eval,"INLINE NUMBER(%d)",value);

			ok = pushValInt(value);
		}

	}

	proc_leave();
	if (ok)
		display(dbg_eval,"getAtom() returning(%s) at %d   val_top=%d   op_top=%d",
				VAL_DISPLAY(&val_stack[val_start]),*offset,val_top,op_top);
	return ok;
}



//============================================================
// evaluate()
//============================================================


bool rigMachine::evaluate(uint8_t byte, const uint8_t *code, uint16_t *offset)
{
	int op_start = op_top;
	int val_start = val_top;
	int cond_start = cond_top;

	display(dbg_eval,"evaluate() at %d  op_start=%d   val_start=%d",*offset - 1,op_start,val_start);
	proc_entry();

	bool ok = 1;
	while (ok && byte != EXP_END && byte != EXP_RIGHT_BRACKET)
	{
		if (byte == EXP_LEFT_PAREN)
		{
			display(dbg_eval,"LEFT_PAREN at %d",*offset);
			ok = pushOp(byte);
			byte = code[(*offset)++];
		}
		else if (byte == EXP_RIGHT_PAREN)
		{
			display(dbg_eval,"RIGHT_PAREN at %d",*offset);
			byte = code[(*offset)++];

			uint8_t op;
			ok = popOp(&op);
			while (ok && op != EXP_LEFT_PAREN)
			{
				ok = doOp(op);
				ok = ok && popOp(&op);
			}
		}
		else if (byte == EXP_NOT)
		{
			// we will push the operand on the stack and just know
			// that it is unary and right-associative
			ok = pushOp(byte);
			byte = code[(*offset)++];
		}
		else if (byte == EXP_QUESTION || byte == EXP_COLON)
		{
			// evaulate any expressions on the stack
			// back to any previous question mark or colon

			display(dbg_eval,"CONDITIONAL(%d=%s) at %d",byte,OP_TOKEN(byte),*offset);
			while (ok && op_top > op_start &&
				   op_stack[op_top-1] != EXP_QUESTION &&
				   op_stack[op_top-1] != EXP_COLON)
			{
				uint8_t op;
				ok = popOp(&op);
				ok = ok && doOp(op);
			}

			// pop the top value to a condition and
			// push the QUESTION op

			if (ok && byte == EXP_QUESTION)
			{
				ok = popValToCondition();
				// ok = ok && pushOp(byte);
			}

			byte = code[(*offset)++];

		}
		else if (IS_EXP_OP(byte))
		{
			display(dbg_eval,"IS_EX_OP(%d=%s) at %d",byte,OP_TOKEN(byte),*offset);
			while (ok && op_top > op_start && precedence(byte) <= precedence(op_stack[op_top-1]))
			{
				uint8_t op;
				ok = popOp(&op);
				ok = ok && doOp(op);
			}
			ok = ok && pushOp(byte);
			byte = code[(*offset)++];
		}

		// otherwise, it's an atom with a possible nested expression

		else
		{
			ok = getAtom(byte,code,offset);	// pushes it on the stack
			byte = code[(*offset)++];
		}
	}

    while (ok && op_top > op_start)
    {
		uint8_t op;
		ok = popOp(&op);
		ok = ok && doOp(op);
    }

	while (ok && cond_top > cond_start)
	{
		uint16_t cond;
		evalResult_t val2;
		evalResult_t val1;

		ok = popCondition(&cond);
		ok = ok && popVal(&val2);
		ok = ok && popVal(&val1);
		ok = ok && pushVal(cond ? &val1 : &val2 );
	}

	proc_leave();

	// this should leave one value on the stack

	if (ok)
	{
		display(dbg_eval,"evaluate() returning %s at %d   op_top=%d  val_top=%d",VAL_DISPLAY(&val_stack[val_start]),*offset,op_top,val_top);
	}
	return ok;
}




//-------------------------
// entry point
//-------------------------

bool rigMachine::expression(evalResult_t *rslt, const uint8_t *code, uint16_t *offset)
{
	display(dbg_eval,"expression at offset %d",*offset);
	proc_entry();

	op_top = 0;
	val_top = 0;
	cond_top = 0;

	uint8_t byte = code[(*offset)++];
	bool ok = evaluate(byte,code,offset);
	if (ok)
		memcpy(rslt,&val_stack[0],sizeof(evalResult_t));

	proc_leave();
	if (ok)
		display(dbg_eval,"expression() returning %s at %d",VAL_DISPLAY(rslt),*offset);
	return ok;
}